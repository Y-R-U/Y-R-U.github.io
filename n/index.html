<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>P2P Chat – Serverless (with diagnostics)</title>
<style>
  :root { --bg:#0b0f14; --fg:#e7edf3; --muted:#9fb0c3; --card:#121923; --accent:#5ec5ff; --warn:#ffb86b; --err:#ff6b6b; }
  html,body{background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;margin:0}
  .wrap{max-width:920px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;margin:0 0 12px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .col{display:flex;flex-direction:column;gap:10px}
  .card{background:var(--card);border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  input[type=text]{background:#0e1621;border:1px solid #1c2a3a;color:var(--fg);border-radius:10px;padding:10px 12px;width:100%}
  button{background:#162434;color:var(--fg);border:1px solid #274663;border-radius:10px;padding:9px 12px;cursor:pointer}
  button.primary{background:var(--accent);color:#04121d;border:none}
  button.warn{background:var(--warn);color:#130c00;border:none}
  button:disabled{opacity:.6;cursor:not-allowed}
  .pill{padding:6px 10px;border-radius:999px;background:#0e1621;border:1px solid #25374c;color:var(--muted);font-size:12px}
  .muted{color:var(--muted)}
  .log{background:#0e1621;border:1px solid #1c2a3a;border-radius:10px;padding:10px;height:340px;overflow:auto}
  .msg{margin:0 0 8px}
  .msg.sys{color:var(--muted);font-style:italic}
  .msg.err{color:var(--err)}
  .roster{display:flex;gap:6px;flex-wrap:wrap}
  .chip{background:#0e1621;border:1px solid #1c2a3a;padding:6px 10px;border-radius:999px}
  .sep{height:1px;background:#1c2a3a;margin:8px 0 12px}
  .small{font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>P2P Chat – Serverless</h1>
  <div class="muted" style="margin:-6px 0 16px">WebRTC data channels; link <b>or</b> code signaling. STUN only (no TURN). <span id="ver" class="small"></span></div>

  <!-- Host controls (compact) -->
  <div id="hostPanel" class="card" style="display:none">
    <div class="row" style="align-items:baseline">
      <span class="pill">Host</span>
      <span id="roomKey" class="pill"></span>
      <span id="roomNamePill" class="pill"></span>
      <span id="statusBadge" class="pill">Idle</span>
      <div class="row" style="margin-left:auto;gap:8px">
        <button id="inviteLinkBtn" disabled>Copy Invite Link</button>
        <button id="inviteCodeBtn" disabled>Copy Invite Code</button>
        <button id="closeBtn" class="warn" disabled>Close Chat</button>
      </div>
    </div>
    <div id="answerCodeRow" class="row" style="margin-top:8px;display:none">
      <input id="answerCodeInput" type="text" placeholder="Paste Answer Code here…">
      <button id="applyAnswerCodeBtn">Apply Answer Code</button>
      <span class="muted small">Only needed if the joiner used a code (not a link).</span>
    </div>
  </div>

  <!-- Joiner panel -->
  <div id="joinPanel" class="card" style="display:none">
    <div class="row" style="align-items:baseline">
      <span class="pill">Join</span>
      <span id="joinRoomKey" class="pill"></span>
      <span id="joinRoomName" class="pill"></span>
      <span id="joinStatus" class="pill" style="margin-left:auto">Connecting…</span>
    </div>
    <div class="row">
      <div class="col" style="min-width:200px;max-width:260px">
        <input id="joinerName" type="text" placeholder="Your display name">
      </div>
      <div class="col" style="min-width:260px">
        <input id="answerOut" type="text" readonly placeholder="Answer Code will appear here">
        <div class="row">
          <button id="copyAnswerCodeBtn">Copy Answer Code</button>
          <button id="copyAnswerLinkBtn">Copy Answer Link</button>
        </div>
        <div class="small muted">Send one of these back to the host.</div>
      </div>
    </div>
  </div>

  <!-- Chat -->
  <div id="chatPanel" class="card" style="display:none">
    <div class="row">
      <div class="roster" id="roster"></div>
    </div>
    <div class="sep"></div>
    <div id="log" class="log"></div>
    <div class="row" style="margin-top:10px">
      <input id="messageInput" type="text" placeholder="Type message… (Enter to send)">
      <button id="sendBtn">Send</button>
      <button id="renameBtn">Rename</button>
    </div>
  </div>

  <!-- Landing -->
  <div id="landingPanel" class="card">
    <div class="row">
      <div class="col grow" style="min-width:320px">
        <div class="small muted">Start a new chat</div>
        <input id="landingName" type="text" placeholder="Chat name">
        <input id="landingDisplay" type="text" placeholder="Your display name">
        <button id="startNewBtn" class="primary">Start New Chat</button>
      </div>
      <div class="col grow" style="min-width:320px">
        <div class="small muted">Join with link or code</div>
        <input id="landingInvite" type="text" placeholder="Paste Invite Link here (or switch to code below)">
        <div class="row">
          <button id="openInviteBtn">Open Link</button>
          <span class="small muted">or</span>
          <input id="inviteCodeIn" type="text" placeholder="Paste Invite Code here">
          <button id="joinWithCodeBtn">Join with Code</button>
        </div>
      </div>
    </div>
  </div>

  <p class="small muted">If it stalls at “Waiting for host…” the host must open the Answer Link (or paste Answer Code). Some networks block STUN; try another network or add TURN.</p>
</div>

<script>
(() => {
  // -------------------- version --------------------
  const VERSION = "diag-1.1";
  document.getElementById("ver").textContent = `v${VERSION}`;

  // -------------------- utilities --------------------
  const $ = id => document.getElementById(id);
  const b64 = {
    enc: obj => btoa(unescape(encodeURIComponent(JSON.stringify(obj)))),
    dec: str => JSON.parse(decodeURIComponent(escape(atob(str))))
  };
  const genKey = () => Math.random().toString(36).slice(2,10).toUpperCase();
  const genId  = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
  const url = new URL(window.location.href);
  const qs  = k => url.searchParams.get(k);
  function show(ids){ const want=Array.isArray(ids)?ids:[ids]; for (const id of ["landingPanel","hostPanel","joinPanel","chatPanel"]) $(id).style.display = want.includes(id) ? "" : "none"; }

  const logEl = $("log");
  function log(msg, cls=""){ const p=document.createElement("div"); p.className="msg "+cls; p.innerHTML=msg; logEl.appendChild(p); logEl.scrollTop=logEl.scrollHeight; }
  function info(msg){ log(`<span class="muted">${msg}</span>`, "msg sys"); }
  function error(msg){ log(`<span class="err">❌ ${msg}</span>`, "msg err"); }
  function copyText(text){ navigator.clipboard.writeText(text).then(()=>info("Copied to clipboard.")).catch(()=>prompt("Copy:", text)); }
  function escapeHtml(s){ return s.replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  const setStatus = s => $("statusBadge") && ($("statusBadge").textContent = s);
  const setJoinStatus = s => $("joinStatus") && ($("joinStatus").textContent = s);

  // -------------------- state --------------------
  const state = {
    isHost:false,
    me:{ id:genId(), name:"" },
    roomKey:genKey(), roomName:"",
    peers:new Map(), closed:false
  };

  // -------------------- roster --------------------
  const roster = new Map();
  function rosterRender(){ const el=$("roster"); if(!el) return; el.innerHTML=""; el.appendChild(chip(state.me.name||"(me)")); for(const [id,name] of roster.entries()) el.appendChild(chip(name)); function chip(n){ const s=document.createElement("span"); s.className="chip"; s.textContent=n; return s; } }
  function rosterSet(list){ roster.clear(); for(const p of list) roster.set(p.id,p.name); rosterRender(); }
  function rosterAdd(id,name){ roster.set(id,name); rosterRender(); }
  function rosterDel(id){ roster.delete(id); rosterRender(); }
  function rosterRename(id,name){ roster.set(id,name); rosterRender(); }

  // -------------------- diagnostics helpers --------------------
  function candidateType(c){
    if (!c || !c.candidate) return "?";
    const m = c.candidate.match(/ typ (\w+) /);
    return m ? m[1] : "?"; // host | srflx | relay
  }
  function logState(pc, label){
    info(`[${label}] iceGathering=${pc.iceGatheringState}, iceConnection=${pc.iceConnectionState}, connection=${pc.connectionState}`);
  }
  function armTimeout(name, ms, onfire){
    const id = setTimeout(onfire, ms);
    return () => clearTimeout(id);
  }

  // -------------------- WebRTC --------------------
  const rtcConfig = { iceServers:[{urls:["stun:stun.l.google.com:19302"]}] };

  async function waitIceComplete(pc){
    if(pc.iceGatheringState==="complete") return;
    await new Promise(res=>{
      pc.addEventListener("icegatheringstatechange", function f(){
        if(pc.iceGatheringState==="complete"){ pc.removeEventListener("icegatheringstatechange", f); res(); }
      });
    });
  }

  function wireDiagnostics(pc, roleLabel){
    pc.onicecandidate = (e) => {
      if (e.candidate) info(`[${roleLabel}] ICE candidate (${candidateType(e.candidate)})`);
      else info(`[${roleLabel}] ICE gathering complete`);
    };
    pc.oniceconnectionstatechange = () => {
      info(`[${roleLabel}] iceConnectionState → ${pc.iceConnectionState}`);
      if (pc.iceConnectionState === "failed") {
        error(`[${roleLabel}] ICE failed. This often means NAT/firewall blocked P2P (try different networks or add TURN).`);
      } else if (pc.iceConnectionState === "disconnected") {
        info(`[${roleLabel}] ICE disconnected (temporary network issue or host didn’t apply the matching Answer).`);
      }
    };
    pc.onconnectionstatechange = () => {
      info(`[${roleLabel}] connectionState → ${pc.connectionState}`);
      if (pc.connectionState === "connected") info(`[${roleLabel}] data channel should open shortly.`);
      if (pc.connectionState === "failed") error(`[${roleLabel}] PeerConnection failed.`);
    };
  }

  function wireDataChannel(dc){
    dc.onopen = () => {
      info(`DataChannel open.`);
      const hello = {t:"hello",from:state.me.id,name:state.me.name,host:state.isHost,room:state.roomKey};
      try { dc.send(JSON.stringify(hello)); } catch(e){ error(`Send hello failed: ${e.message}`); }
    };
    dc.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }
      if(msg.t==="hello"){
        if(state.isHost){
          const entry=[...state.peers.entries()].find(([_,v])=>v.dc===dc || v.pc?.sctp===dc?.sctp);
          if(entry){
            const [tmp,p]=entry;
            state.peers.delete(tmp);
            state.peers.set(msg.from,{...p,name:msg.name,role:"guest",dc});
            rosterRender();
            info(`Joined: ${escapeHtml(msg.name)}`);
            const rosterMsg={t:"roster",host:state.me,peers:[...state.peers.entries()].filter(([id,p])=>id!==msg.from && p.role!=="guest-pending").map(([id,p])=>({id,name:p.name}))};
            try { dc.send(JSON.stringify(rosterMsg)); } catch(e){ error(`Send roster failed: ${e.message}`); }
            broadcast(msg.from,{t:"joined",id:msg.from,name:msg.name});
          }
        } else {
          const host=state.peers.get("host"); if(host) host.dc=dc;
        }
      } else if(msg.t==="roster"){ rosterSet(msg.peers);
      } else if(msg.t==="joined"){ rosterAdd(msg.id,msg.name);
      } else if(msg.t==="left"){ rosterDel(msg.id);
      } else if(msg.t==="rename"){ rosterRename(msg.id,msg.name);
      } else if(msg.t==="chat"){
        if(!state.isHost){ printChat(msg.id===state.me.id?"(me)":msg.name,msg.text,msg.id===state.me.id); }
        else{ broadcast(msg.id,msg); printChat(msg.name,msg.text,false); }
      } else if(msg.t==="closed"){ state.closed=true; setJoinStatus("Closed by host"); info("Chat closed by host."); }
    };
    dc.onclose = () => info("DataChannel closed.");
    dc.onerror = (e) => error(`DataChannel error: ${e.message || e}`);
  }

  function broadcast(fromId,payload){
    for(const [pid,p] of state.peers.entries()){
      if(!p.dc || p.dc.readyState!=="open") continue;
      if(pid===fromId) continue;
      try { p.dc.send(JSON.stringify(payload)); } catch(e){ error(`Broadcast to ${pid} failed: ${e.message}`); }
    }
  }

  // Host creates an offer for one invite
  async function hostCreateInvite(inviteId){
    const pc = new RTCPeerConnection(rtcConfig);
    wireDiagnostics(pc, "HOST");
    const dc = pc.createDataChannel("chat",{ordered:true});
    wireDataChannel(dc);
    pc.onconnectionstatechange = () => {
      info(`[HOST] connectionState → ${pc.connectionState}`);
      if (pc.connectionState==="failed" || pc.connectionState==="disconnected"){
        for(const [pid,p] of state.peers.entries()){
          if(p.pc===pc){ state.peers.delete(pid); rosterRender(); info(`Pending peer (${escapeHtml(p.name||pid)}) disconnected.`); }
        }
      }
    };
    const offer = await pc.createOffer().catch(e => { error(`createOffer failed: ${e.message}`); throw e; });
    await pc.setLocalDescription(offer).catch(e => { error(`setLocalDescription(offer) failed: ${e.message}`); throw e; });
    wireDiagnostics(pc,"HOST"); // in case state changed
    info("Offer created; gathering ICE…");
    await waitIceComplete(pc);
    info("Offer ready (ICE complete). Ask a joiner to use this invite (link or code).");

    // store pending invite so an Answer Link opened later can find it
    localStorage.setItem(`invite:${inviteId}`, JSON.stringify({inviteId,roomKey:state.roomKey,sdp:pc.localDescription,ts:Date.now()}));

    state.peers.set(inviteId,{pc,dc,name:"(connecting…)",role:"guest-pending"});
    rosterRender();
    return pc.localDescription;
  }

  // Host applies a joiner's answer
  async function hostApplyAnswer(inviteId, answer){
    const p = state.peers.get(inviteId);
    if(!p){ error("No pending invite found that matches this Answer. Did you generate a new invite since?"); throw new Error("No pending invite"); }
    info("Applying Answer from joiner…");
    await p.pc.setRemoteDescription(answer).catch(e => { error(`setRemoteDescription(answer) failed: ${e.message}`); throw e; });
    info("Answer applied. Waiting for ICE to connect…");
  }

  // Joiner consumes the host's offer
  async function joinWithOffer(inviteId, offer){
    const pc = new RTCPeerConnection(rtcConfig);
    wireDiagnostics(pc, "JOIN");
    pc.ondatachannel = e => { wireDataChannel(e.channel); };
    pc.onconnectionstatechange = () => {
      info(`[JOIN] connectionState → ${pc.connectionState}`);
      if (pc.connectionState==="connecting") setJoinStatus("Waiting for host to apply your answer…");
      if (pc.connectionState==="connected") setJoinStatus("Connected");
      if (pc.connectionState==="failed" || pc.connectionState==="disconnected") setJoinStatus("Connection failed/disconnected");
    };
    await pc.setRemoteDescription(offer).catch(e => { error(`setRemoteDescription(offer) failed: ${e.message}`); throw e; });
    info("Creating Answer…");
    const answer = await pc.createAnswer().catch(e => { error(`createAnswer failed: ${e.message}`); throw e; });
    await pc.setLocalDescription(answer).catch(e => { error(`setLocalDescription(answer) failed: ${e.message}`); throw e; });
    info("Answer created; gathering ICE…");
    await waitIceComplete(pc);
    info("Answer ready. Send Answer Link/Code to host and wait for them to apply it.");
    state.peers.set("host",{pc,dc:null,name:"(host)",role:"host"});
    return pc.localDescription;
  }

  // -------------------- chat send/rename --------------------
  $("sendBtn").onclick = sendChat;
  $("messageInput").addEventListener("keydown", e => { if(e.key==="Enter") sendChat(); });
  function printChat(who,text,isMe=false){ log(`<span class="who${isMe?' me':''}"><b>${escapeHtml(who)}</b>:</span> ${escapeHtml(text)}`); }
  function sendChat(){
    const txt = $("messageInput").value.trim(); if(!txt) return; $("messageInput").value="";
    if(state.isHost){ printChat(state.me.name,txt,true); broadcast(state.me.id,{t:"chat",id:state.me.id,name:state.me.name,text:txt}); }
    else{
      const host=state.peers.get("host");
      if(host?.dc?.readyState==="open"){ host.dc.send(JSON.stringify({t:"chat",id:state.me.id,name:state.me.name,text:txt})); printChat("(me)",txt,true); }
      else info("Not connected yet.");
    }
  }
  $("renameBtn").onclick = () => {
    const n = prompt("Enter new display name:", state.me.name || "");
    if(!n) return; state.me.name = n; rosterRender();
    if(state.isHost) broadcast(state.me.id,{t:"rename",id:state.me.id,name:n});
    else{ const host=state.peers.get("host"); host?.dc?.send(JSON.stringify({t:"rename",id:state.me.id,name:n})); }
  };

  // -------------------- UI: start / invite / close --------------------
  $("startNewBtn").onclick = async () => {
    // start host
    state.isHost = true;
    state.roomKey = genKey();
    state.roomName = $("landingName").value.trim() || "My Chat";
    state.me.name = $("landingDisplay").value.trim() || "Host";
    $("roomKey").textContent = `Room ${state.roomKey}`;
    $("roomNamePill").textContent = state.roomName;
    $("inviteLinkBtn").disabled = false;
    $("inviteCodeBtn").disabled = false;
    $("closeBtn").disabled = false;
    show(["hostPanel","chatPanel"]);
    $("landingPanel").style.display="none";
    rosterRender();
    setStatus("Waiting for peers…");
    info("Chat created. Use Copy Invite Link or Copy Invite Code.");
    history.replaceState({}, "", location.pathname+`?room=${state.roomKey}&host=1&name=${encodeURIComponent(state.me.name)}&title=${encodeURIComponent(state.roomName)}`);
  };

  $("inviteLinkBtn").onclick = async () => {
    const inviteId = genId();
    const offer = await hostCreateInvite(inviteId);
    $("answerCodeRow").style.display = "";
    const payload = {v:1,kind:"offer",invite:inviteId,room:state.roomKey,title:state.roomName,sdp:offer};
    const link = location.origin + location.pathname + "?join=1&data=" + encodeURIComponent(b64.enc(payload));
    copyText(link);
    setStatus("Invite ready (link)");
    info("Invite Link copied. Ask joiner to open it, then send back the Answer Link (host should open it).");
    // safety timer: if answer not applied in 90s, remind
    armTimeout("host-wait-answer", 90000, ()=>info("Still waiting for an Answer. Generate a fresh invite if needed."));
  };

  $("inviteCodeBtn").onclick = async () => {
    const inviteId = genId();
    const offer = await hostCreateInvite(inviteId);
    $("answerCodeRow").style.display = "";
    const payload = {v:1,kind:"offer",invite:inviteId,room:state.roomKey,title:state.roomName,sdp:offer};
    copyText(b64.enc(payload));
    setStatus("Invite ready (code)");
    info("Invite Code copied. Joiner will return an Answer Code; paste it here and click Apply.");
  };

  $("applyAnswerCodeBtn").onclick = async () => {
    try{
      const obj = b64.dec($("answerCodeInput").value.trim());
      if(obj.kind!=="answer") throw new Error("Not an Answer Code");
      await hostApplyAnswer(obj.invite, obj.sdp);
      info("Answer applied. If it doesn’t connect within ~20s, try a new invite or another network.");
      $("answerCodeInput").value = "";
    }catch(e){ error("Failed to apply answer: " + e.message); }
  };

  $("openInviteBtn").onclick = () => {
    const link = $("landingInvite").value.trim();
    if(link) window.location.href = link;
  };

  $("joinWithCodeBtn").onclick = async () => {
    try{
      const obj = b64.dec($("inviteCodeIn").value.trim());
      if(obj.kind!=="offer") throw new Error("Not an Invite Code");
      startJoinFlow(obj);
    }catch(e){ error("Invalid code: " + e.message); }
  };

  $("closeBtn").onclick = () => {
    state.closed = true;
    broadcast(state.me.id,{t:"closed"});
    for(const [id,p] of state.peers.entries()){ try{p.dc?.close(); p.pc?.close();}catch{} state.peers.delete(id); }
    roster.clear(); rosterRender();
    setStatus("Closed");
    info("Chat closed.");
  };

  // -------------------- boot via URL or Code --------------------
  (async function boot(){
    const encoded = qs("data"), isJoin = qs("join"), hostFlag = qs("host"),
          room = qs("room"), title = qs("title")||"", name = qs("name")||"";

    if(hostFlag){
      state.isHost = true;
      show(["hostPanel","chatPanel"]);
      $("roomKey").textContent = `Room ${room||"?"}`;
      $("roomNamePill").textContent = decodeURIComponent(title||"");
      $("inviteLinkBtn").disabled = false;
      $("inviteCodeBtn").disabled = false;
      $("closeBtn").disabled = false;
      state.roomKey = room || state.roomKey;
      state.roomName = decodeURIComponent(title||"");
      state.me.name = decodeURIComponent(name||"");
      setStatus("Waiting for peers…");
      rosterRender();
      info("Host view restored.");
      // If this URL is actually an Answer Link, auto-apply it (host-only convenience)
      if (encoded) {
        try{
          const obj = b64.dec(decodeURIComponent(encoded));
          if (obj.kind === "answer") {
            const saved = JSON.parse(localStorage.getItem(`invite:${obj.invite}`) || "null");
            if (!saved) error("This Answer does not match a pending invite in this browser/tab.");
            else {
              info("Auto-applying Answer from link…");
              await hostApplyAnswer(obj.invite, obj.sdp);
              info("Answer auto-applied from link.");
              setTimeout(()=>history.replaceState({}, "", location.pathname+`?room=${state.roomKey}&host=1&name=${encodeURIComponent(state.me.name)}&title=${encodeURIComponent(state.roomName)}`), 1200);
            }
          }
        } catch(e){ error("Failed to auto-apply Answer from link: " + e.message); }
      }
      return;
    }

    if(isJoin && encoded){
      try {
        const obj = b64.dec(decodeURIComponent(encoded));
        startJoinFlow(obj);
      } catch(e){
        error("Bad invite link: " + e.message);
      }
    }
  })();

  async function startJoinFlow(obj){
    if(!obj || obj.kind!=="offer"){ show("landingPanel"); return; }
    state.isHost=false; state.roomKey=obj.room; state.roomName=obj.title||"";
    $("joinRoomKey").textContent=`Room ${state.roomKey}`;
    $("joinRoomName").textContent=state.roomName;
    show(["joinPanel","chatPanel"]);
    const storedName = localStorage.getItem("webrtc-name") || "";
    $("joinerName").value = storedName || "";
    state.me.name = storedName || ("Guest-"+Math.random().toString(36).slice(2,6).toUpperCase());
    localStorage.setItem("webrtc-name", state.me.name);

    setJoinStatus("Connecting… (creating answer)");
    const answer = await joinWithOffer(obj.invite, obj.sdp);
    const ansPayload = {v:1,kind:"answer",invite:obj.invite,room:state.roomKey,sdp:answer};
    $("answerOut").value = b64.enc(ansPayload);
    $("copyAnswerCodeBtn").onclick = ()=>copyText($("answerOut").value);
    const ansLink = location.origin + location.pathname + "?data=" + encodeURIComponent(b64.enc(ansPayload)) + `&host=1&room=${encodeURIComponent(state.roomKey)}&title=${encodeURIComponent(state.roomName)}&name=${encodeURIComponent(state.me.name)}`;
    $("copyAnswerLinkBtn").onclick = ()=>copyText(ansLink);
    info("Answer ready. Send the Answer Code (or Link) to the host. Then wait for them to apply it.");
    // remind after 60s if host hasn't applied
    armTimeout("join-wait", 60000, ()=>info("Still waiting for host to apply your Answer…"));
    $("joinerName").addEventListener("change", ()=>{
      state.me.name = $("joinerName").value.trim() || state.me.name;
      localStorage.setItem("webrtc-name", state.me.name);
      const host = state.peers.get("host");
      host?.dc?.readyState==="open" && host.dc.send(JSON.stringify({t:"rename",id:state.me.id,name:state.me.name}));
    });
  }
})();
</script>
</body>
</html>
